<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>垂直変位推定（高精度ヒューリスティック版）</title>
  <style>
    body { font-family: sans-serif; margin: 2em; }
    #log { margin-top: 1em; padding: 0.5em; background: #eee; max-height: 300px; overflow-y: auto; }
    button { padding: 0.5em 1em; font-size: 16px; }
  </style>
</head>
<body>
  <h1>垂直変位推定（高精度ヒューリスティック版）</h1>
  <p>縦方向の変位: <span id="displacement">0.00</span> m</p>
  <button id="startBtn">センサー開始</button>
  <div id="log"></div>
  
  <script>
    // ログ出力用関数（デバッグ用）
    function log(msg) {
      console.log(msg);
      document.getElementById('log').innerHTML += msg + '<br>';
    }

    // 積分用グローバル変数
    let verticalVelocity = 0;      // 垂直速度（m/s）
    let verticalDisplacement = 0;  // 垂直変位（m）
    let lastTime = null;           // 前回イベント時刻（ms）

    // 高域通過フィルタ用変数（加速度のノイズ軽減用）
    let filteredVerticalAcc = 0;
    const alphaFilter = 0.9;       // 加速度フィルタ係数（0～1、1に近いほど前回値重視）

    // 漏洩積分（コンプリメンタリフィルタ）のパラメータ
    const velocityDecay = 0.98;    // 速度の漏洩率（0～1、1に近いほどドリフトが残る）

    // スライディングウィンドウによる加速度統計用
    const slidingWindowDuration = 0.5; // 窓の長さ（秒）
    let slidingWindow = [];             // { time, value } を蓄積

    // 静止判定用のパラメータ
    const accStdThreshold = 0.05;       // 窓内加速度の標準偏差がこれ未満なら加速度的に静止
    const gyroThreshold = 1.0;          // 回転速度が1°/s未満なら回転的に静止（各軸）
    
    // 現在のデバイスの向き（オイラー角：α, β, γ）
    let currentOrientation = { alpha: 0, beta: 0, gamma: 0 };

    /**
     * デバイスの向きが変化したときのハンドラ  
     * event.alpha, beta, gamma は度（°）で提供されるので、ラジアンに変換する
     */
    function handleOrientation(event) {
      currentOrientation.alpha = event.alpha ? event.alpha * Math.PI / 180 : 0;
      currentOrientation.beta  = event.beta  ? event.beta  * Math.PI / 180 : 0;
      currentOrientation.gamma = event.gamma ? event.gamma * Math.PI / 180 : 0;
      log('Orientation: α=' + event.alpha + '°, β=' + event.beta + '°, γ=' + event.gamma + '°');
    }

    /**
     * オイラー角から、デバイス座標 → 地球座標への回転行列を計算する  
     * （W3C DeviceOrientation Event の定義に基づく一例）
     */
    function getRotationMatrix(alpha, beta, gamma) {
      const cA = Math.cos(alpha), sA = Math.sin(alpha);
      const cB = Math.cos(beta),  sB = Math.sin(beta);
      const cG = Math.cos(gamma), sG = Math.sin(gamma);
      // Z (alpha) → X (beta) → Y (gamma) の順に回転とみなす
      const r11 = cA * cG - sA * sB * sG;
      const r12 = -cB * sA;
      const r13 = cA * sG + cG * sA * sB;
      const r21 = cG * sA + cA * sB * sG;
      const r22 = cA * cB;
      const r23 = sA * sG - cA * cG * sB;
      const r31 = -cB * sG;
      const r32 = sB;
      const r33 = cB * cG;
      return [
        [r11, r12, r13],
        [r21, r22, r23],
        [r31, r32, r33]
      ];
    }

    /**
     * スライディングウィンドウに新たな加速度値を追加し、古い値を削除する
     */
    function updateSlidingWindow(time, value) {
      slidingWindow.push({ time: time, value: value });
      // ウィンドウ期間外のデータを削除
      while (slidingWindow.length && (time - slidingWindow[0].time) > slidingWindowDuration * 1000) {
        slidingWindow.shift();
      }
    }

    /**
     * スライディングウィンドウ内の標準偏差を計算する
     */
    function calcStdInWindow() {
      if (slidingWindow.length === 0) return 0;
      let sum = 0;
      slidingWindow.forEach(item => sum += item.value);
      const mean = sum / slidingWindow.length;
      let variance = 0;
      slidingWindow.forEach(item => {
        const diff = item.value - mean;
        variance += diff * diff;
      });
      variance /= slidingWindow.length;
      return Math.sqrt(variance);
    }

    /**
     * 加速度センサーの値から垂直方向のネット加速度を求め、
     * 複数のヒューリスティック（スライディングウィンドウ＋ジャイロチェック＋漏洩積分）により、
     * 速度・変位を更新するハンドラ
     */
    function handleMotion(event) {
      // accelerationが取得できなければ、accelerationIncludingGravityを利用
      const accSource = event.acceleration ? event.acceleration : event.accelerationIncludingGravity;
      if (!accSource || accSource.x === null) {
        log('加速度データが取得できません。');
        return;
      }

      const currentTime = event.timeStamp;
      if (lastTime === null) {
        lastTime = currentTime;
        return;
      }
      const dt = (currentTime - lastTime) / 1000; // 経過時間（秒）
      lastTime = currentTime;

      const ax = accSource.x, ay = accSource.y, az = accSource.z;

      // 回転行列を利用して、デバイス座標の加速度を地球座標へ変換
      const R = getRotationMatrix(currentOrientation.alpha, currentOrientation.beta, currentOrientation.gamma);
      // 地球座標系での垂直方向（Z軸）の加速度
      const aEarthZ = R[2][0] * ax + R[2][1] * ay + R[2][2] * az;

      // ネット加速度の算出
      // event.accelerationが存在すれば重力は除かれている前提
      // なければ、加速度IncludingGravityから 9.81 m/s² を差し引く
      let netVerticalAcc;
      if (event.acceleration) {
        netVerticalAcc = aEarthZ;
      } else {
        netVerticalAcc = aEarthZ - 9.81;
      }

      // 高域通過フィルタでノイズ軽減
      filteredVerticalAcc = alphaFilter * filteredVerticalAcc + (1 - alphaFilter) * netVerticalAcc;

      // スライディングウィンドウに加速度を記録し、統計値を計算
      updateSlidingWindow(currentTime, filteredVerticalAcc);
      const windowStd = calcStdInWindow();

      // ジャイロによる回転状態のチェック
      let isGyroStationary = true;
      if (event.rotationRate) {
        // rotationRate: α, β, γ（deg/s）
        const { alpha, beta, gamma } = event.rotationRate;
        if (Math.abs(alpha) > gyroThreshold || Math.abs(beta) > gyroThreshold || Math.abs(gamma) > gyroThreshold) {
          isGyroStationary = false;
        }
      }
      
      // ヒューリスティックな静止判定:
      // ・加速度の標準偏差が小さい（例：0.05 m/s²未満）かつ
      // ・ジャイロがほぼ静止（各軸1°/s未満）
      const isStationary = (windowStd < accStdThreshold) && isGyroStationary;
      if (isStationary) {
        if (verticalVelocity !== 0) {
          log('静止状態検出（windowStd=' + windowStd.toFixed(3) + '）→ 速度リセット');
        }
        verticalVelocity = 0;
      } else {
        // 漏洩積分による速度更新
        verticalVelocity = velocityDecay * (verticalVelocity + filteredVerticalAcc * dt);
      }

      // 速度から変位を更新
      verticalDisplacement += verticalVelocity * dt;

      // 結果を表示
      document.getElementById("displacement").innerText = verticalDisplacement.toFixed(2);
      log('Motion: dt=' + dt.toFixed(3) + ' s, netAcc=' + netVerticalAcc.toFixed(3) +
          ' m/s², filteredAcc=' + filteredVerticalAcc.toFixed(3) +
          ' m/s², stdWindow=' + windowStd.toFixed(3) +
          ', v=' + verticalVelocity.toFixed(3) +
          ' m/s, disp=' + verticalDisplacement.toFixed(3) + ' m');
    }

    // センサー開始処理（ユーザー操作必須）
    function startSensors() {
      log('startSensors() が呼ばれました。');
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(response => {
            log('requestPermissionの結果: ' + response);
            if (response === 'granted') {
              window.addEventListener('deviceorientation', handleOrientation);
              window.addEventListener('devicemotion', handleMotion);
              document.getElementById("startBtn").style.display = 'none';
              log('センサーのイベントリスナーを登録しました。');
            } else {
              log('センサー利用の許可が得られませんでした。');
              alert("センサー利用の許可が得られませんでした。");
            }
          })
          .catch(error => {
            log('許可リクエストエラー: ' + error);
          });
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
        window.addEventListener('devicemotion', handleMotion);
        document.getElementById("startBtn").style.display = 'none';
        log('センサーのイベントリスナーを登録しました。（requestPermission不要な環境）');
      }
    }

    // 「センサー開始」ボタンのクリックイベント登録
    document.getElementById("startBtn").addEventListener("click", startSensors);
  </script>
</body>
</html>
